# **Шпаргалка по GIT. Работа с командной строкой.**
----
Команды для синхронизации локального репозитория с удалённым.

git remote add origin https://github.com/YandexPracticum/first-project.git — находясь в папке с локальным репозиторием, привязываем его к удалённому (URL у вас будет свой);

git push -u origin main — заливаем все файлы из локального репозитория в удалённый, который уже привязали.
====
Команды для того чтобы сделать сохранение — коммит.

git add название_файла — готовим выбранный файл к коммиту;

git add -A — чтобы ничего не потерять, можно подготовить к коммиту сразу все файлы, в которых были изменения;

git commit -m "комментарий к коммиту" — делаем коммит. К сохранённым файлам оставляем комментарий для того, чтобы проще было понять, какие сделаны изменения.

Забыл что-то добавить в коммит— git commit --amend:

Запуск команды откроет Vim. Он предложит изменить комментарий к последнему коммиту. Нажмите i, чтобы начать писать, и введите новый комментарий к коммиту. Как закончите, нажмите esc, введите :wq и нажмите Enter. Так вы сохраните новый комментарий и выйдете из Vim.

git log — посмотреть подробный лог коммитов.

git log --oneline — посмотреть короткий просмотр коммитов.

git diff — посмотреть изменения в «рабочей зоне»; они маркируются гитом как modifided, new или deleted.

git diff --staged — посмотреть изменения, добавленные в staged.

git diff a9928ab 11bada1 — сравнить изменения двух коммитов.

----
Команды для публикации изменений:

git pull — забрать изменения, сделанные другими разработчиками;

git push — опубликовать изменения в удалённый репозиторий.

----
Команды для отмены изменений:

Когда всё перестаёт работать, проще всего откатиться назад — вернуться к последнему коммиту. За это отвечает команда git reset.

git reset HEAD. Подход не затрагивает файлы, с которыми вы работаете. Если файл был изменён или добавлен, но не переведён в staged, сброс изменений этот файл не затронет.

git reset --hard. Команда удаляет вообще все изменения: и из staged, и из рабочей зоны. После неё вернуть изменения не выйдет.

Команда git reset --hard позволяет вернуться к любому коммиту. Для этого после команды указывают номер коммита — первые 7 цифр его хеша.

----
Команды для работы с ветками:

git branch название_ветки — создать новую ветку.

git checkout название_ветки — переключиться в ветку.

git checkout -b название_ветки — создать ветку и сразу переключиться в неё.

git branch -D название_ветки — удалить ветку. Чтобы всё прошло хорошо, нужно переключиться из удаляемой ветки.

git merge название_ветки — скопировать все изменения из ветки в ветку. Чтобы перенести изменения из ветки develop в ветку main, нужно находиться в ветке main и ввести git merge develop;

git revert -m основной_родитель хеш_коммита — отмена коммита слияния веток. Опция -m со значением больше 0 указывает на основную ветку, которая будет сохранена.

git revert хеш_коммита — отмена изменений выбранного коммита. Он не был создан при слиянии, поэтому имеет одного предка.

git stash — скрытие незакоммиченных изменений в текущей рабочей ветке. Опция save название_стэша даёт этим изменениям имена.

git stash pop — возврат последних изменений в любой ветке.

git stash list — показ списка спрятанных во всех ветках изменений и, если для стэша не задано имя, последнего коммита в этой ветке.

git stash apply stash@{n} — возврат выбранных спрятанных изменений из листа стэша, где n — номер в нём.

git stash clear — очистка листа стеша.

----
## **Работа с командной строкой - bash**

pwd — покажи в какой я папке;

ls — покажи файлы в папке, где я сейчас;

cd first-project — перейди в папку first-project;

cd first-project/html — перейди в папку html, находящуюся в папке first-project;

cd .. — перейди на уровень выше в родительскую папку;

cd ~ — перейди в домашнюю директорию (у нас это /Users/stas_basov);

mkdir second-project — в текущей папке создай папку с именем second-project;

rm about.html — удали файл about.html;

rmdir images — удали папку images;

rm -r second-project — удали папку second-project и всё, что она содержит;

touch index.html — создай файл index.html в текущей папке;

touch index.html style.css script.js — если нужно создать несколько файлов, их имена можно вводить через пробел.

----
Быстрая навигация

↑ — показать предыдущую команду из буфера.

↓ — показать следующую команду из буфера.

Tab — автоматически дописать команду или путь.

Ctrl + A — перейти в начало строки.

Ctrl + E — перейти в конец строки.

----
Копирование и перемещение

cp — копировать файл. После команды перечисляют файлы для копирования, а затем — директорию, где должны оказаться копии.

mv — переместить файл. Синтаксис аналогичен команде cp.

----
Полезные команды

Команды можно передавать терминалу списком, разделяя двумя амперсандами &&.

Скопировать кодBASH# создали папку, перешли в неё, создали два файла, инициализировали гит mkdir simple && cd simple && touch index.html style.css && git init

----
Просмотр и редактирование

cat — вывести на экран содержимое текстового файла.

cat -n — выполнить команду cat, пронумеровав строки.

cat -s — выполнить команду cat, удалив повторяющиеся строки.

----
### **Текстовый редактор Vim**

esc — перейти в командный режим, например, для выхода из vim.

i — перейти в командный режим для редактирования, например, чтобы оставить комментарий.

esc и :q! — выйти из vim, не сохранив файл.

esc и :wq — выйти из vim, сохранив файл.


----
#### **Хеш — идентификатор коммита**

	•	Git преобразует информацию о коммитах с помощью алгоритма SHA-1 и для каждого из них 		рассчитывает уникальный идентификатор — хеш.
	•	Хеш — основной идентификатор коммита и позволяет узнать его автора, дату и содержимое 		закоммиченных файлов.
	•	Все хеши, а также таблицу соответствий хеш → информация о коммите Git хранит в папке. 	git.

----

##### **Получить сокращённый лог — git log --oneline**

Получить сокращённый лог можно с помощью команды git log с флагом --oneline (англ. «одной строкой»). В терминале появятся только первые несколько символов хеша каждого коммита и их комментарии.
Сокращённый лог полезен, если в репозитории уже много коммитов — например, сотни или тысячи. В этом случае можно быстро найти нужный по описанию.

	•	Можно вызвать не только полный лог, но и сокращённый — это делается командой git log 		--oneline.
	•	В сокращённом логе выводятся сокращённые хеши — их можно использовать точно так же, 		как и полные.

----


###### **HEAD — всему голова**
При вызове команды git log вы также могли заметить надпись (HEAD -> master) после хеша одного из коммитов. 
Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки. git. Он указывает на коммит, который сделан последним (то есть на самый новый).
В этом можно убедиться с помощью терминала. Перейдите в папку. git командой cd. Посмотрите содержимое файла HEAD командой cat.
Когда вы делаете коммит, Git обновляет refs/heads/master — записывает в него хеш последнего коммита. Получается, что HEAD тоже обновляется, так как ссылается на refs/heads/master.
При работе с Git указатель HEAD используется довольно часто. Мы уже упоминали, что многие команды Git принимают в качестве параметра хеш коммита. Если нужно передать последний коммит, то вместо его хеша можно просто написать слово HEAD — Git поймёт, что вы имели в виду последний коммит.

Папка. git содержит много непонятных файлов 

	•	В числе прочих файлов в папке. git есть служебный файл HEAD. Он указывает на самый 	свежий коммит.
	•	Вместо хеша последнего коммита можно написать слово HEAD — Git вас поймёт.


----

### **Статусы файлов в Git**
Разберём подробнее, в каких состояниях (или статусах) могут находиться файлы в репозитории. А ещё проследим типичный жизненный цикл файла в Git.
Статусы untracked/tracked, staged и modified

Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом. Рассмотрим основные.
	•	untracked (англ. «неотслеживаемый») 

Мы говорили, что новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add.
 
	•	staged (англ. «подготовленный»)

После выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged.
В одном из предыдущих уроков мы сравнили коммит с фотографией. Можно развить эту аналогию и сказать, что команда git add добавляет персонажей (текущее содержимое файла или нескольких файлов) на сцену (англ. stage) для общей фотографии, а git commit делает снимок всей сцены целиком. 
Staging area также называют index (англ. «каталог») или cache (англ. «кеш»), а состояние файла staged иногда называют indexed или cached.
Все три варианта могут встречаться в документации и в качестве флагов команд Git. А также в интернете — например, в вопросах и ответах на сайте Stack Overflow.
	•	tracked (англ. «отслеживаемый»)
 
Состояние tracked — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения. 

	•	modified (англ. «изменённый») 

Состояние modified означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён. 
Про staged и modified
Команда git add добавляет в staging area только текущее содержимое файла. Если вы, например, сделаете git add file.txt, а затем измените file.txt, то новое содержимое файла не будет находиться в staging.
Git сообщит об этом с помощью статуса modified: файл изменён относительно той версии, которая уже в staging. Чтобы добавить в staging последнюю версию, нужно выполнить git add file.txt ещё раз.
Типичный жизненный цикл файла в Git

Может показаться, что файлы в репозитории попадают в разные состояния хаотично. На практике это не так, и у большинства файлов вполне предсказуемый путь.
	1.	Файл только что создали. Git ещё не отслеживает содержимое этого файла. Состояние: 			untracked.
	2.	Файл добавили в staging area с помощью git add. Состояние: staged (+ tracked). 
		o	Возможно, изменили файл ещё раз. Состояния: staged, modified (+ tracked). 		Обратите 		внимание: staged и modified у одного файла, но у разных его 		версий.
		Ещё раз выполнили git add. Состояние: staged (+ tracked).
	3.	Сделали коммит с помощью git commit. Состояние: tracked.
	4.	Изменили файл. Состояние: modified (+ tracked).
	5.	Снова добавили в staging area с помощью git add. Состояния: staged (+ tracked).
	6.	Сделали коммит. Состояния: tracked.
	7.	Повторили пункты 4−74−7 много-много раз.

Выглядит довольно запутанно! Но на практике разобраться с этим будет проще, чем кажется. 

Важное:
	•	Статусом untracked помечается файл, о существовании которого Git знает, но не следит 			за изменениями в нём. Этот статус — противоположность tracked, в который попадают все 		файлы, 	отслеживаемые Git.
	•	Файл переходит в статус staged после выполнения git add.
	•	Статус modified означает, что файл был изменён.
	•	Большинство файлов в проектах «шагает» по следующему циклу: «изменён» → «добавлен в 			список на коммит» → «закоммичен» → «изменён» → и так далее.


----